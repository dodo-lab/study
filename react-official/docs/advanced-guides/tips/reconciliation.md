# 差分検出処理

React は２つの仮定に基づくことで、再レンダーの要否を判定するアルゴリズムを実装している。

1. 異なる型の２つの要素は異なるツリーを生成する
2. 開発者は key プロパティを与えることで、異なるレンダー間でどの子要素が変化しない可能性があるのかについてヒントを出すことができる

## 差分アルゴリズム

２つのツリーが異なっている場合、React は最初に２つのルート要素を比較する。

### 異なる型の要素

ルート要素が異なる型を持つ場合、React は常に古いツリーを破棄して新しいツリーをゼロから構築する。例えば`<a>`から`<img>`、`<Article>`から`<Comment>`、`<Button>`から`<div>`へルート要素を変更するとツリーが再構築される。

ツリーを破棄する時点で、古い DOM ノードも破棄される。破棄されるコンポーネントのインスタンスは`componentWillUnmount()`を受け取る。新しいツリーを構築する時点で、新しい DOM ノードが DOM に挿入される。新しいコンポーネントのインタスタンスは`UNSAFE_componentWillMount()` と`componentDidMount()`を受け取る。古いツリーに関連付けられたすべての`state`は失われる。

例えば以下のように、ルート要素が異なる型に更新されると、更新前の古い`Counter`コンポーネントは破棄される。そして、更新後の新しい`Counter`コンポーネントがマウントされる。

- 更新前

  ```js
  <div>
    <Counter />
  </div>
  ```

- 更新後

  ```js
  <span>
    <Counter />
  </span>
  ```

### 同じ型の DOM 要素

同じ型の２つの DOM 要素を比較した場合、React はそれぞれの属性を調べ、変更された属性のみ更新する。例えば以下の場合、`className`のみが更新される。

- 更新前

  ```js
  <article className="before" title="stuff" />
  ```

- 更新後

  ```js
  <article className="after" title="stuff" />
  ```

この DOM ノードを更新した後、React は子要素に対して再帰的に差分検出を行う。

### 同じ型のコンポーネント要素

コンポーネントが更新される場合、インスタンスは変わらず、`state`が保持される。React は更新対象のコンポーネントのインスタンスの props を更新し、`UNSAFE_componentWillReceiveProps()`、`UNSAFE_componentWillUpdate()`、`componentDidUpdate()`がコールされる。

### 子要素の再帰的な処理

DOM ノードの子要素に対して再帰的に差分検出をする場合、React は更新前後の両方の子要素のリストをそれぞれ比較していく。そして差分を見つけたところで、以降はすべて更新されたものとして扱う。

例えば以下のような場合は、特に問題なく動作する。

- 更新前

  ```html
  <ul>
    <li>first</li>
    <li>second</li>
  </ul>
  ```

- 更新後

  ```html
  <ul>
    <li>first</li>
    <li>second</li>
    <li>third</li>
  </ul>
  ```

具体的な動作としては以下のようになる。

1. 更新前後の１つ目の`li要素`を比較し、一致しているため何もしない
2. 更新前後の２つ目の`li要素`を比較し、一致しているため何もしない
3. 更新後のみに３つ目の`li要素`があるため、要素を追加する

もし、先頭に要素を追加した場合はパフォーマンスに悪影響を及ぼす。例えば以下のような場合、すべての子要素が要更新と判断し、再レンダーされる。

- 更新前

  ```html
  <ul>
    <li>Duke</li>
    <li>Villanova</li>
  </ul>
  ```

- 更新後

  ```html
  <ul>
    <li>Connecticut</li>
    <li>Duke</li>
    <li>Villanova</li>
  </ul>
  ```

React は`<li>Duke</li>`と`<li>Villanova</li>`をそのまま保持できるという事に気付かず、すべての子要素を変更してしまう。非効率で問題となるため、次の節で解決策を提示する。
