# Performance | React Native Docs

## [パフォーマンスの概要](https://reactnative.dev/docs/performance)

React Native では「開発者メニュー」で「Show Perf Monitor」をタッチし、パフォーマンスのモニタリングを有効にすることが可能。アプリにオーバーレイする形でパフォーマンスが表示される。

### FPS

パフォーマンスモニタを有効にすると、２種類の FPS が表示されている。

#### JS frame rate (JavaScript スレッド)

JavaScript スレッドにおけるフレームレート。ほとんどの React Native アプリにおいて、ビジネスロジックは JavaScript スレッドで実行される。JavaScript スレッドが１フレームの間応答しない場合、ネイティブ側でそのフレームはドロップされたものとみなされる。

例えば、複雑なアプリのルートコンポーネントでステートを更新し、計算量の多いコンポーネントツリーの再レンダリングを行った場合を考えてみる。仮に再レンダリングに 200ms 要したとすると、12 フレームがドロップされることになる。その間、JavaScript で制御しているアニメーションはフリーズしているように見えてしまう。

これはナビゲーションの移行時によく起こる。新しいルートをプッシュした時、JavaScript スレッドはシーンに必要なすべてのコンポーネントをレンダリングし、バックビューを作成するためにネイティブ側に適切なコマンドを送信する必要がある。ここでの処理には数フレーム要するのが一般的。また、コンポーネントが`componentDidMount`で追加で処理をするケースもあり、ナビゲーションの際に２回フリーズが発生してしまう可能性がある。

もう１つの例として、タッチの応答が挙げられる。JavaScript スレッドが複数のフレームにまたがって処理をしている場合、たとえば`TouchableOpacity`への応答が遅れることがある。これは、JavaScript スレッドが多忙でメインスレッドが送られてきたタッチイベントを処理できないため。その結果、`TouchableOpacity`はタッチイベントに反応できず、ネイティブビューに不透明度の調整を指示できない。

#### UI frame rate (メインスレッド)

ネイティブ側のメインスレッドにおけるフレームレート。例えば、`Animated`の`useNativeDriver`設定で考えてみる。`useNativeDriver`を`有効(true)`にすることで、ネイティブ側にすべてのアニメーション情報を送信し、アニメーション開始以降はブリッジを介さずメインスレッドでアニメーションを制御をする。それにより、JavaScript スレッドでのフレームドロップが発生しなくなる。もし、JavaScript スレッドが多忙だったとしても、既に開始したアニメーションへの影響はない。

同様に、ScrollView はメインスレッド上に存在するため、JavaScript スレッドに疎外されることなく上下にスクロールできる。

## パフォーマンス問題の主な原因

### 開発モードでの実行

開発モードで実行すると、JavaScript スレッドのパフォーマンスが大きく低下する。これは、propsType の検証や様々なアサーションなど、適切な警告やエラーメッセージを提供するためのトレードオフ。パフォーマンス検証は必ずリリースビルドした成果物で行うこと。

### console.log の使用

console.log は JavaScript スレッドで大きなボトルネックになる可能性がある。`redux-logger`のようなデバッグライブラリからの呼び出しも含まれるため、バンドルする前に削除する必要がある。これは、以下のように babel プラグインを利用することでも解決可能。

- babel プラグインのインストール

  ```shell
  npm i -D babel-plugin-transform-remove-console
  ```

- babel プラグインの設定

  プロジェクトディレクトリの`.babelrc`を編集。

  ```json
  {
    "env": {
      "production": {
        "plugins": ["transform-remove-console"]
      }
    }
  }
  ```

これにより、プロジェクトのリリースバージョンでは、すべての`console.*`呼び出しが自動的に削除される。

### ListView の初期レンダリングが遅い／大きなリストのスクロールパフォーマンスが悪い

[FlatList][] または、[SectionList][] コンポーネントを使用すべき。これらのコンポーネントは、パフォーマンスが大幅に向上している。主な改善点は、行数に関わらずメモリ使用量がほぼ一定であること。

[FlatList][] のレンダリングが遅い場合は、`getItemLayout` を実装して、レンダリングされたアイテムの測定をスキップすることでレンダリング速度を最適化する。

### ほぼ変化のない再レンダリングで、JS の FPS が低下する

`ListView`を使用している場合、`rowHasChanged`関数を提供する必要がある。この関数は、対象行を再レンダリングする必要があるかどうかを素早く判断し、多くの作業を削減することが可能。

同様に、`shouldComponentUpdate`を実装し、コンポーネントの再レンダリングが必要な条件を正確に示すことでも改善可能。ただし、大量のオブジェクトのリストを詳細に比較する必要がある場合は、コンポーネント全体を再レンダリングした方が早いかもしれない点は注意。

### View をトランスフォーム(移動や回転など)すると、UI の FPS が低下する

透明なテキストを画像の上に配置していたり、フレームごとに View を再描画する場合、顕著にあらわれる。`shouldRasterizeIOS`や`renderToHardwareTextureAndroid`を有効にすることで解決できる可能性がある。

ただし、この機能を使いすぎると、メモリ使用量が急激に増加する可能性があるため注意が必要。そのため、使用前後でのパフォーマンスとメモリ使用量をチェックしておくべき。また、View を動かす必要がなくなったら、この機能はオフにすること。

### Image のサイズをアニメーション化すると、UI の FPS が低下する

iOS では、Image コンポーネントの幅や高さを調整するたびに、元画像から再トリミングとスケーリングが行われる。大きな画像の場合は FPS 低下が顕著になる。

対策としては、幅や高さを調整する代わりに、`transform: [{scale}]`のスタイルプロパティを使用すること。

### TouchableXxx の応答性が悪い

タッチに反応するコンポーネントの不透明度やハイライトの調整と同じフレーム内でアクションを実行すると、onPress のハンドラ関数が終了するまでその効果が確認できない可能性がある。例えば、onPress のハンドラ関数内でのステート更新によって、多くの更新作業が発生したとする。それにより、数フレームがドロップした場合に応答性が悪くなってしまう。

この問題を解決するには、onPress のハンドラ関数内すべてのアクションを`requestAnimationFrame`でラップする。

```js
handleOnPress() {
  requestAnimationFrame(() => {
    this.doExpensiveAction();
  });
}
```

[flatlist]: https://reactnative.dev/docs/flatlist
[sectionlist]: https://reactnative.dev/docs/sectionlist
